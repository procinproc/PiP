#!@python@
# -*- mode:python -*-

# $PIP_license: <Simplified BSD License>
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
#     Redistributions of source code must retain the above copyright notice,
#     this list of conditions and the following disclaimer.
#
#     Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
# THE POSSIBILITY OF SUCH DAMAGE.
# $
# $RIKEN_copyright: Riken Center for Computational Sceience (R-CCS),
# System Software Development Team, 2016-2021
# $
# $PIP_VERSION: Version 3.1.0$
#
# $Author: Atsushi Hori (R-CCS)
# Query:   procinproc-info@googlegroups.com
# User ML: procinproc-users@googlegroups.com
# $

"pips: Show status of runnning PiP tasks"

from __future__ import print_function
import os
import signal
import sys
import subprocess as sp

try :
    import fnmatch as fnm
    flag_fnmatch = True
except:
    flag_fnmatch = False


wtab = { 'USER':  8,
         'TT':    8,
         'TTY':   8,
         'START': 7 }

cmdself = os.path.basename( sys.argv.pop(0) )

check_gen    = None
check_out    = None
check_output = None

def print_usage( errmsg ):
    "print usage and exit"
    global check_gen, check_out, check_output
    print( cmdself+':', errmsg, file=sys.stderr )
    if check_gen is not None or check_out is not None:
        print( cmdself+':', errmsg, file=check_output )
    print( 'Usage:', cmdself, '[a][u][x] <PIPS_OPTIONS> [<CMDS>]', file=sys.stderr )
    sys.exit( 1 )

def eprint( msg ):
    "error message"
    global check_gen, check_out, check_output
    print( cmdself.upper()+':', msg, file=sys.stderr )
    if check_gen is not None or check_out is not None:
        print( cmdself.upper()+':', msg, file=check_output )

def ex_print( msg ):
    "print error message and exit"
    eprint( msg )
    try:
        if check_out is not None:
            check_output.close()
    except:
        pass
    sys.exit( 1 )

SIGTAB = [ ( 'HUP',   signal.SIGHUP  ), # 1
           ( 'INT',   signal.SIGINT  ), # 2
           ( 'QUIT',  signal.SIGQUIT ), # 3
           ( 'ILL',   signal.SIGILL  ), # 4
           ( 'TRAP',  signal.SIGTRAP ), # 5
           ( 'ABRT',  signal.SIGABRT ), # 6
           ( 'BUS',   signal.SIGBUS  ), # 7
           ( 'FPE',   signal.SIGFPE  ), # 8
           ( 'KILL',  signal.SIGKILL ), # 9
           ( 'USR1',  signal.SIGUSR1 ), # 10
           ( 'SEGV',  signal.SIGSEGV ), # 11
           ( 'USR2',  signal.SIGUSR2 ), # 12
           ( 'PIPE',  signal.SIGPIPE ), # 13
           ( 'ALRM',  signal.SIGALRM ), # 14
           ( 'TERM',  signal.SIGTERM ), # 15
           ( 'CHLD',  signal.SIGCHLD ), # 17
           ( 'CLD',   signal.SIGCHLD ), # 17
           ( 'CONT',  signal.SIGCONT ), # 18
           ( 'STOP',  signal.SIGSTOP ), # 19
           ( 'TSTP',  signal.SIGTSTP ), # 20
           ( 'TTIN',  signal.SIGTTIN ), # 21
           ( 'TTOU',  signal.SIGTTOU ), # 22
           ( 'URG',   signal.SIGURG  ), # 23
           ( 'XCPU',  signal.SIGXCPU ), # 24
           ( 'XFSZ',  signal.SIGXFSZ ), # 25
           ( 'VTALRM', signal.SIGVTALRM ), # 26
           ( 'PROF',  signal.SIGPROF ), # 27
           ( 'WINCH', signal.SIGWINCH ), # 28
           ( 'IO',    signal.SIGIO   ), # 29
##         ( 'PWR',   signal.SIGPWR  ), # 30
           ( 'SYS',   signal.SIGSYS  )  # 31
]

def check_signal( sig ):
    "check if the specified signal is valid or not"
    global SIGTAB
    if sig is None:
        return None
    try:
        signum = int( sig )
        if signum < 0 or signum > signal.NSIG:
            return None
        for ( name, signo ) in SIGTAB:
            if signum == signo:
                return ( name, signo )
        return None
    except ValueError:
        try:
            signame = sig.upper()
            if signame[0:3] == 'SIG':
                signame = signame[3:]
            for ( name, signo ) in SIGTAB:
                if signame == name:
                    return ( name, signo )
            return None
        except KeyError:
            return None

def delimit( lst, delimiter ):
    "flatten list"
    if lst == [] or lst is None:
        return []

    token = lst.pop( 0 )
    if delimiter is not None and delimiter in token:
        return token.split( delimiter ) + delimit( lst, delimiter )
    return [ token ] + delimit( lst, delimiter )

error = False

ps_ax        = ''
flag_bsd_u   = False
flag_root    = True
flag_task    = True
flag_family  = False
thread_mode  = False
flag_kill    = False
flag_verbose = False
flag_debug   = False
ps_opts      = None
top_opts     = None
killsig      = None
mode_sel     = None

selections = []

def is_option( opt ):
    "check if option"
    if opt is None:
        return False
    return opt[0] == '-'

def is_skip( opt ):
    "check if the skip argument"
    if opt is None:
        return True
    return opt in [ '-', '--' ]

check_gen = os.environ.get( 'PIPS_CHECK_GEN' )
check_out = os.environ.get( 'PIPS_CHECK_OUT' )
# for checking
if check_gen is not None and check_out is not None:
    print_usage( '????' )
# generating test data for checking afterwords
if check_gen is not None:
    check_input  = open( check_gen+'.input',  mode='w' )
    check_output = open( check_gen+'.output', mode='w' )
    print( 'simply ignore this line', file=check_input )
if check_out is not None:
    check_output = open( check_out+'.check',  mode='w' )

if len(sys.argv) > 0:
    args = sys.argv
    aux = args[0]

    if aux[0] != '-':
        if 'a' in aux:
            ps_ax = ps_ax + 'a'
        if 'x' in aux:
            ps_ax = ps_ax + 'x'
        if 'u' in aux:
            flag_bsd_u = True
        if ps_ax != '' or flag_bsd_u:
            args.pop(0)

    argc = len(args)
    idx  = 0
    while idx < argc:
        opt = args[idx]
        idx += 1
        if idx < argc:
            nxt = args[idx]
        else:
            nxt = None
        if opt in [ '--root', '-r' ]:
            flag_task = False
        elif opt in [ '--task', '-t' ]:
            flag_root = False
        elif opt in [ '--family', '-f' ]:
            flag_family = True
        elif opt in [ '--mode', '-m' ]:
            if nxt is None:
                print_usage( 'No mode specified' )
            else:
                nxtu = nxt.upper()
                for m in nxtu:
                    if not m in "PLGCT":
                        print_usage( 'Invalid mode' )
                mode_sel = nxtu
            idx += 1
        elif opt in [ '--kill', '-k' ]:
            flag_kill = True
        elif opt in [ '--signal', '-s' ]:
            if nxt is None or is_skip( nxt ) or is_option( nxt ):
                print_usage( 'No signal specified' )
            if killsig is not None: # killsig is already set
                print_usage( 'Multiple signal options' )
            killsig = check_signal( nxt )
            if killsig is None:
                print_usage( 'Invalid signal' )
            idx += 1
        elif opt in [ '--ps', '-P' ]:
            if ps_opts is None:
                ps_opts = []
            if not is_skip( nxt ):
                ps_opts = ps_opts + nxt.split( ',' )
                idx += 1
        elif opt in [ '--top', '-T' ]:
            if top_opts is None:
                top_opts = []
            if not is_skip( nxt ):
                top_opts = top_opts + nxt.split( ',' )
                idx += 1
        elif opt in [ '--verbose', '-v' ]:
            flag_verbose = True
        elif opt == '--debug':
            flag_debug = True
        elif is_skip( opt ):
            continue
        elif opt[0] == '-':
            print_usage( 'Unknown option: ' + opt )
        else:
            selections = args[idx-1:]
            break
        continue

if flag_debug:
    print( 'Selections:', selections )
    print( 'mode_sel:', mode_sel )

if ps_opts is not None and top_opts is not None:
    ex_print( 'either --ps or --top can be specified' )

if killsig is not None and ps_opts is not None:
    ex_print( 'either --signal or --ps options can be specified' )
if killsig is not None and top_opts is not None:
    ex_print( 'either --signal or --top options can be specified' )
if flag_kill and killsig is not None:
    ex_print( 'either --kill or --signal can be specified' )
if flag_kill and ps_opts is not None:
    ex_print( 'either --kill or --ps can be specified' )
if flag_kill and top_opts is not None:
    ex_print( 'either --kill or --top can be specified' )
if flag_kill or killsig is not None:
    tgkill_path = os.path.abspath( 
        os.path.join( os.path.join( os.getcwd(), os.path.dirname( __file__ ) ),
                      "pip-tgkill" ) )
    if not os.path.exists( tgkill_path ):
        ex_print( tgkill_path + ' not found' )
if flag_kill:
    killsig = ( 'TERM',  signal.SIGTERM )

pips_postfix = 'comm tid pid ppid'
if flag_bsd_u:
    fmt = 'user pid tid %cpu %mem vsz rss tty stat start_time cputime'
else:
    fmt = 'pid tid tty stat time'
ps_cmd = [ 'ps', ps_ax+'H', '--format' ] + [ fmt + ' ' + pips_postfix ]

if flag_debug:
    print( ps_cmd, file=sys.stderr )

def byte_to_char( byte_str ):
    "convert byte string to char (for compatibility between Python2 and 3)"
    try:
        if byte_str == '' or byte_str[0] in 'abc':
            ch_str = byte_str   # python2
        else:
            ch_str = byte_str
    except:                     # python3
        ch_str = byte_str.decode()
    return ch_str

def get_command( psline ):
    "get command from the ps output line"
    return psline[-4]

def get_tid( psline ):
    "get TID from the ps output line"
    return psline[-3]

def get_pid( psline ):
    "get PID from the ps output line"
    return psline[-2]

def get_ppid( psline ):
    "get PPID from the ps output line"
    return psline[-1]

def format_header( header ):
    "re-format the header line of ps output"
    head = header[:-3]
    head.insert( -1, 'PIP' )
    return head

def get_mode( cmd ):
    second = cmd[1]
    if second == ':':
        mode = 'L'
    elif second == ';':
        mode = 'C'
    elif second == '.':
        mode = 'G'
    elif second == '|':
        mode = 'T'
    else:
        mode = '?'
    return mode

def format_psline( psline ):
    "re-format from the ps format to the pips format"
    cmd = get_command( psline )
    first  = cmd[0]
    mode = get_mode( cmd );
    line = psline[:-4]
    line += [ first+mode, cmd[2:] ]
    return line

def pip_symbol( sym ):
    "check if sym is a pip symbol"
    if sym in ":;.|?":
        return True
    return False

def pip_root_symbol( sym ):
    "check if sym is the root symbol"
    if sym == 'R':
        return True
    return False

def pip_task_symbol( sym ):
    "check if sym is the task symbol"
    if sym in '0123456789':
        return True
    return False

def get_mode_symbol( ps ):
    "return PiP execution mode symbol"
    cmd = get_command( ps )
    return cmd[1]

def is_threaded( mode ):
    "check if the execution mode is thread"
    if mode == '|':
        return True
    return False

def isa_piproot( cmd ):
    "check if root task or not"
    global thread_mode
    if pip_root_symbol( cmd[0] ):
        return True
    return False

def isa_piptask( cmd ):
    "check if the PiP task or not"
    global thread_mode
    if pip_task_symbol( cmd[0] ):
        return True
    return False

def is_selected( ps, cmd, patterns ):
    "check if the psline matches the patterns"
    if patterns == []:
        return True

    tid = get_tid( ps )
    if tid in patterns:
        return True
    pid = get_pid( ps )
    if pid in patterns:
        return True
    if len(cmd) > 2 and cmd[2:] in patterns:
        return True

    if flag_fnmatch:
        for pat in patterns:
            if fnm.fnmatch( cmd[2:], pat ):
                return True
    return False

def have_pc_relation( parent, child ):
    "check if they have the parent-child relationship"
    mp = get_mode_symbol( parent )
    mc = get_mode_symbol( child  )
    if mp != mc:
        return False
    if is_threaded( mp ):
        if get_pid( parent ) == get_pid( child ):
            return True
        return False
    if get_pid( parent ) == get_ppid( child ):
        return True
    return False

def check_mode( cmd, mode ):
    "check is the mode of the command is the one to be selected"
    m = get_mode( cmd )
    #print( 'check_mode( ', cmd, ' , ', mode, ' , ', m,  ' )' )
    if 'P' in mode:
        if m in 'LCG':
            return True
        else:
            return False
    elif m in mode:
        return True
    else:
        return False

os.environ['LANG'] = 'C'
piplines = []

def read_ps_output( fstream ):
    "parse the ps output"
    global piplines, thread_mode, header

    while True:
        ps = byte_to_char( fstream.readline() )
        if ps == '':
            break
        if check_gen is not None:
            print( ps, end='', file=check_input )

        psl = ps.split()
        if header is None:
            header = psl
        else:
            cmd = get_command( psl )
            if isa_piproot( cmd ) or isa_piptask( cmd ):
                piplines += [ psl ]
                if is_threaded( cmd[1] ):
                    thread_mode = True
        continue

header = None

fstream = None
if check_out == None:
    psproc = sp.Popen( ps_cmd, stdout=sp.PIPE )
    fstream = psproc.stdout
    read_ps_output( fstream )
else:
    fstream = open( check_out+'.input', mode='r' )
    fstream.readline() # skip the very first line
    read_ps_output( fstream )

patterns = []
for select in selections:
    patterns += [ select ]

if not flag_root and not flag_task:
    flag_root = True
    flag_task = True

all_roots = []
all_tasks = []
sel_roots = []
sel_tasks = []
for ps in piplines:
    cmd = get_command( ps )
    if isa_piproot( cmd ):
        all_roots += [ ps ]
        if is_selected( ps, cmd, patterns ):
            sel_roots += [ ps ]
    elif isa_piptask( cmd ):
        all_tasks += [ ps ]
        if is_selected( ps, cmd, patterns ):
            sel_tasks += [ ps ]

if flag_debug:
    print( 'all_roots:', all_roots )
    print( 'all_tasks:', all_tasks )
    print( 'sel_roots:', sel_roots )
    print( 'sel_tasks:', sel_tasks )

if flag_family:
    fmly_roots = []
    fmly_tasks = []
    for rs in sel_roots:
        fmly_roots += [ rs ]
        for ts in all_tasks:
            # if rs is multi-threaded, same ts may appaer twice or more
            if have_pc_relation( rs, ts ) and ts not in fmly_tasks:
                fmly_tasks += [ ts ]
    for ts in sel_tasks:
        for rs in all_roots:
            if have_pc_relation( rs, ts ) and rs not in fmly_roots:
                fmly_roots += [ rs ]
    for rs in fmly_roots:
        for ts in all_tasks:
            if have_pc_relation( rs, ts ) and ts not in fmly_tasks:
                fmly_tasks += [ ts ]
    sel_roots = fmly_roots
    sel_tasks = fmly_tasks

if mode_sel is not None:
    sel = []
    for rs in sel_roots:
        cmd = get_command( rs )
        if check_mode( cmd, mode_sel ):
            sel += [ rs ]
    sel_roots = sel
    sel = []
    for ts in sel_tasks:
        cmd = get_command( ts )
        if check_mode( cmd, mode_sel ):
            sel += [ ts ]
    sel_tasks = sel

if flag_debug:
    print( 'sel_roots:', sel_roots )
    print( 'sel_tasks:', sel_tasks )

all_tasks = []
if not flag_root and not flag_task:
    all_tasks = sel_roots + sel_tasks
if flag_root:
    all_tasks += sel_roots
if flag_task:
    all_tasks += sel_tasks

if all_tasks == []:
    ex_print( 'no PiP task found' )

def sort_tid( psline ):
    "sort lines with TID"
    return int( get_tid( psline ) )

all_tasks.sort( key=sort_tid )

if flag_debug:
    for ps in all_tasks:
        print( ps )

def kill_task( ps, killsig ):
    ( signame, signum ) = killsig
    try:
        cmd = get_command( ps )
        tid = get_tid( ps )
        pid = get_pid( ps )
        if flag_verbose:
            print( 'pip-tgkill ' + signame + ' ' + 
                   pid + ' ' + tid + 
                   ' (' + cmd + ')' )
        if check_gen is None and check_out is None:
            sp.check_call( [ tgkill_path, str(signum), pid, tid, 'no_esrch' ] )
        else:
            print( 'pip-tgkill', signame, tid, cmd, file=check_output )
    except Exception as e:
        print( tgkill_path + ' ', signame + ' ' + 
               pid + ' ' + tid + 
               ' (' + cmd + '): ', e )

if killsig is not None:
    # tasks must be killed at first
    if flag_task:
        for ps in sel_tasks:
            kill_task( ps, killsig );
    if flag_root:
        for ps in sel_roots:
            kill_task( ps, killsig );

elif ps_opts is not None:
    ps_cmd = 'ps'
    ps_uH = ''
    if flag_bsd_u:
        ps_uH += 'u'
    if thread_mode:
        ps_uH += 'H'
    ps_opts = [ ps_ax + ps_uH ] + ps_opts
    pid_list = []
    for ps in all_tasks:
        pid = get_pid( ps )
        if not pid in pid_list:
            pid_list += [ pid ]
    try:
        if check_gen is None and check_out is None:
            if flag_debug:
                print( ps_cmd, ps_opts, pid_list )
            os.execvp( ps_cmd, [ps_cmd] + ps_opts + pid_list )
        else:
            print( 'execvp(', ps_cmd, ' '.join(ps_opts+pid_list), ')',
                   file=check_output )
    except Exception as e:
        eprint( 'execvp(ps):' + str(e) )

elif top_opts is not None:
    top_cmd = 'top'
    if thread_mode:
        top_opts += [ '-H' ]
    pid_list = []
    for ps in all_tasks:
        pid_list += [ get_pid( ps ) ]
    pid_opt = [ '-p', ','.join( pid_list ) ]
    try:
        if check_gen is None and check_out is None:
            if flag_debug:
                print( ps_cmd, top_opts, pid_opt )
            os.execvp( top_cmd, [top_cmd] + top_opts + pid_opt )
        else:
            print( 'execvp(', top_cmd, ' '.join(top_opts+pid_opt), ')',
                   file=check_output )
    except Exception as e:
        eprint( 'execvp(top):' + str(e) )

else:
    out_list = []
    if flag_family:
        for pr in sel_roots:
            if flag_root:
                out_list += [ pr ]
            if flag_task:
                for pt in all_tasks:
                    if have_pc_relation( pr, pt ):
                        out_list += [ pt ]
    else:
        for ps in all_tasks:
            out_list += [ ps ]
    # format
    outl = [ format_header( header ) ]
    for out in out_list:
        outl += [ format_psline( out ) ]
    w = []
    for tkn in outl[0]:
        if tkn in wtab:
            w += [ wtab[tkn] + 1 ]
        else:
            w += [ len(tkn) + 1 ]
    for line in outl[1:]:
        idx = 0
        for tkn in line:
            wt = len( tkn ) + 1
            if wt > w[idx]:
                w[idx] = wt
            idx += 1
    # output
    for line in outl:
        idx = 0
        for tkn in line:
            print( tkn.ljust(w[idx]), end='' )
            if check_gen is not None or check_out is not None:
                print( tkn.ljust(w[idx]), end='', file=check_output )
            idx += 1
        print( '' )             # newline
        if check_gen is not None or check_out is not None:
            print( '', file=check_output )

if check_gen is not None or check_out is not None:
    check_output.close()

if error:
    sys.exit( 1 )
